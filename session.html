<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Debug Session — DebugArena</title>
<link rel="stylesheet" href="style.css">
<!-- Supabase MUST load before app.js -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
<style>
html, body { height: 100%; overflow: hidden; margin: 0; padding: 0; }

/* PRE-SESSION PROMPT */
#fs-prompt {
  position: fixed; inset: 0; z-index: 99999; background: var(--bg);
  display: flex; align-items: center; justify-content: center;
  flex-direction: column; gap: 18px; text-align: center; padding: 40px;
}
.fs-icon { font-size: 64px; animation: fsPulse 2s ease-in-out infinite; }
@keyframes fsPulse { 0%,100%{transform:scale(1);filter:drop-shadow(0 0 10px rgba(0,245,160,0.3));} 50%{transform:scale(1.07);filter:drop-shadow(0 0 24px rgba(0,245,160,0.6));} }
.fs-title { font-family: var(--font-display); font-size: 26px; font-weight: 900; color: var(--white); letter-spacing: 3px; }
.fs-sub   { font-size: 13px; color: var(--text3); max-width: 380px; line-height: 1.8; }
.fs-rules {
  padding: 16px 28px; background: var(--red-dim);
  border: 1px solid rgba(255,45,85,0.25); border-radius: var(--r2);
  color: var(--text); font-family: var(--font-mono); font-size: 12.5px;
  max-width: 460px; line-height: 2; text-align: left;
}
.fs-rules span { color: var(--red); font-weight: 700; }
.fs-start {
  padding: 13px 44px; background: var(--neon); border: none;
  border-radius: var(--r); color: var(--bg);
  font-family: var(--font-display); font-size: 13px; font-weight: 900;
  letter-spacing: 2px; cursor: pointer; transition: all 0.2s;
}
.fs-start:hover    { background: var(--neon2); box-shadow: 0 6px 28px var(--neon-glow); transform: translateY(-2px); }
.fs-start:disabled { background: var(--bg4); color: var(--text3); cursor: not-allowed; transform: none; box-shadow: none; }

/* TAB-SWITCH CONFIRMATION (Feature 1) */
#tab-confirm-overlay {
  position: fixed; inset: 0; z-index: 99997;
  background: rgba(0,0,0,0.9); backdrop-filter: blur(10px);
  display: none; align-items: center; justify-content: center;
}
#tab-confirm-overlay.show { display: flex; animation: fadeIn 0.15s ease; }
.tab-confirm-box {
  background: var(--bg2); border: 2px solid var(--red);
  border-radius: var(--r3); padding: 40px 48px;
  text-align: center; max-width: 460px; width: 90%;
  box-shadow: 0 0 80px rgba(255,45,85,0.3); animation: riseIn 0.25s ease;
}
.tc-icon  { font-size: 52px; display: block; margin-bottom: 14px; animation: shakeIcon 0.5s ease; }
@keyframes shakeIcon { 0%,100%{transform:rotate(0);} 25%{transform:rotate(-10deg);} 75%{transform:rotate(10deg);} }
.tc-title { font-family: var(--font-display); font-size: 20px; font-weight: 900; color: var(--red); letter-spacing: 2px; margin-bottom: 8px; }
.tc-msg   { font-size: 13px; color: var(--text3); margin-bottom: 4px; line-height: 1.7; }
.tc-msg strong { color: var(--red); }
.tc-ring-wrap  { margin: 20px auto 22px; text-align: center; }
.tc-ring-label { font-size: 10px; color: var(--text3); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 10px; }
.tc-ring {
  width: 72px; height: 72px; border-radius: 50%; margin: 0 auto;
  display: flex; align-items: center; justify-content: center;
  background: conic-gradient(var(--red) 360deg, var(--bg3) 360deg);
  position: relative; transition: background 0.1s;
}
.tc-ring::before { content:''; position:absolute; inset:6px; border-radius:50%; background:var(--bg2); }
.tc-ring-num  { font-family: var(--font-display); font-size: 26px; font-weight: 900; color: var(--red); position: relative; z-index: 1; }
.tc-btns { display: flex; gap: 12px; }
.tc-ok {
  flex: 1; padding: 12px; border-radius: var(--r); background: var(--red);
  border: none; color: #fff; font-family: var(--font-display);
  font-size: 12px; font-weight: 700; letter-spacing: 1px; cursor: pointer; transition: all 0.2s;
}
.tc-ok:hover { background: var(--red2); box-shadow: 0 4px 16px var(--red-glow); }
.tc-cancel {
  flex: 1; padding: 12px; border-radius: var(--r); background: var(--bg3);
  border: 1px solid var(--border2); color: var(--text); font-family: var(--font-display);
  font-size: 12px; font-weight: 700; letter-spacing: 1px; cursor: pointer; transition: all 0.2s;
}
.tc-cancel:hover { border-color: var(--neon); color: var(--neon); }

/* TERMINATION OVERLAY */
#term-overlay {
  position: fixed; inset: 0; z-index: 99996; background: #000;
  display: none; align-items: center; justify-content: center;
  flex-direction: column; text-align: center; gap: 14px;
}
#term-overlay.show { display: flex; animation: fadeIn 0.3s ease; }
.term-scanline {
  position: absolute; inset: 0; pointer-events: none;
  background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(255,45,85,0.025) 2px, rgba(255,45,85,0.025) 4px);
}
.term-icon  { font-size: 72px; z-index: 1; animation: shakeIcon 0.5s ease; }
.term-title { font-family: var(--font-display); font-size: 32px; font-weight: 900; color: var(--red); letter-spacing: 4px; z-index: 1; text-shadow: 0 0 40px var(--red-glow); }
.term-reason-box { font-family: var(--font-mono); font-size: 13px; color: var(--red); background: var(--red-dim); border: 1px solid rgba(255,45,85,0.2); border-radius: var(--r2); padding: 11px 22px; z-index: 1; max-width: 440px; }
.term-sub-txt { font-size: 13px; color: var(--text3); z-index: 1; max-width: 360px; line-height: 1.7; }
.term-eval-note { font-size: 12px; color: var(--purple); z-index: 1; background: var(--purple-dim); border: 1px solid rgba(191,90,242,0.2); border-radius: var(--r2); padding: 8px 18px; }
.term-back { margin-top: 4px; z-index: 1; padding: 11px 28px; background: var(--red-dim); border: 1px solid rgba(255,45,85,0.3); border-radius: var(--r); color: var(--red); font-family: var(--font-display); font-size: 12px; font-weight: 700; letter-spacing: 1px; cursor: pointer; transition: all 0.2s; }
.term-back:hover { background: rgba(255,45,85,0.2); }

/* COMPLETE OVERLAY */
#complete-overlay {
  position: fixed; inset: 0; z-index: 9990; background: var(--bg);
  display: none; align-items: center; justify-content: center;
  flex-direction: column; text-align: center; gap: 12px;
}
#complete-overlay.show { display: flex; animation: fadeIn 0.5s ease; }

/* SESSION UI */
#session-ui { display: none; height: 100vh; flex-direction: column; }
#session-ui.active { display: flex; }

/* TOP BAR */
.sess-topbar { height: 52px; flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; background: var(--bg2); border-bottom: 1px solid var(--border); z-index: 50; gap: 12px; }
.sess-left   { display: flex; align-items: center; gap: 10px; min-width: 0; flex: 1; }
.sess-prob-icon { width: 30px; height: 30px; border-radius: 6px; flex-shrink: 0; background: var(--neon-dim); border: 1px solid rgba(0,245,160,0.2); display: flex; align-items: center; justify-content: center; color: var(--neon); }
.sess-prob-name { font-family: var(--font-display); font-size: 13px; font-weight: 700; color: var(--white); letter-spacing: 0.5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 260px; }
.sess-prob-meta { font-size: 10px; color: var(--text3); margin-top: 1px; }
.sess-center { flex-shrink: 0; display: flex; align-items: center; gap: 10px; }
.timer-block { display: flex; align-items: center; gap: 8px; padding: 6px 16px; background: var(--bg3); border: 1px solid var(--border2); border-radius: var(--r); }
.timer-val { font-family: var(--font-display); font-size: 20px; font-weight: 900; color: var(--neon); letter-spacing: 2px; min-width: 62px; text-align: center; transition: color 0.3s; }
.timer-val.warn   { color: var(--yellow); animation: tpulse 1s ease-in-out infinite; }
.timer-val.danger { color: var(--red);    animation: tpulse 0.5s ease-in-out infinite; }
@keyframes tpulse { 0%,100%{opacity:1;} 50%{opacity:0.4;} }
.sess-right  { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
.round-badge-top { font-family: var(--font-display); font-size: 10px; font-weight: 700; letter-spacing: 1px; padding: 4px 10px; border-radius: 4px; }
.run-btn { display: flex; align-items: center; gap: 7px; padding: 8px 18px; border-radius: var(--r); background: var(--neon); color: var(--bg); border: none; font-family: var(--font-display); font-size: 11px; font-weight: 900; letter-spacing: 1px; cursor: pointer; transition: all 0.2s; }
.run-btn:hover    { background: var(--neon2); box-shadow: 0 4px 16px var(--neon-glow); }
.run-btn:disabled { background: var(--bg4); color: var(--text3); cursor: not-allowed; box-shadow: none; }
.exit-btn { padding: 7px 14px; border-radius: var(--r); background: var(--red-dim); border: 1px solid rgba(255,45,85,0.2); color: var(--red); font-family: var(--font-display); font-size: 11px; font-weight: 700; cursor: pointer; transition: all 0.2s; }
.exit-btn:hover { background: rgba(255,45,85,0.2); }

/* INFO STRIP */
.info-strip { flex-shrink: 0; padding: 7px 20px; background: var(--bg3); border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 20px; flex-wrap: wrap; font-size: 12px; color: var(--text3); }
.info-strip strong { color: var(--white); }

/* SESSION BODY */
.sess-body { flex: 1; display: flex; overflow: hidden; min-height: 0; }

/* QUESTION SIDEBAR (Feature 4) */
.q-sidebar { width: 230px; flex-shrink: 0; background: var(--bg2); border-right: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
.q-sidebar-head { padding: 11px 16px; border-bottom: 1px solid var(--border); font-size: 10px; font-weight: 700; color: var(--text3); text-transform: uppercase; letter-spacing: 2px; flex-shrink: 0; display: flex; align-items: center; justify-content: space-between; }
.q-progress-mini { font-family: var(--font-mono); font-size: 11px; color: var(--neon); }
.q-list { flex: 1; overflow-y: auto; padding: 8px; }
.q-item { display: flex; align-items: center; gap: 10px; padding: 9px 11px; border-radius: var(--r); cursor: pointer; transition: all 0.15s; border: 1px solid transparent; margin-bottom: 4px; }
.q-item:hover:not(.terminated) { background: var(--bg3); border-color: var(--border2); }
.q-item.active     { background: var(--neon-dim); border-color: rgba(0,245,160,0.25); }
.q-item.solved     { border-color: rgba(0,245,160,0.12); }
.q-item.terminated { opacity: 0.55; cursor: default; border-color: rgba(255,45,85,0.12); }
.q-num { width: 26px; height: 26px; border-radius: 5px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; font-family: var(--font-display); font-size: 11px; font-weight: 700; background: var(--bg4); color: var(--text3); border: 1px solid var(--border2); transition: all 0.15s; }
.q-item.active .q-num     { background: var(--neon);  color: var(--bg);  border-color: var(--neon); }
.q-item.solved .q-num     { background: rgba(0,245,160,0.15); color: var(--neon); border-color: rgba(0,245,160,0.3); }
.q-item.terminated .q-num { background: var(--red-dim); color: var(--red); border-color: rgba(255,45,85,0.3); }
.q-info { flex: 1; min-width: 0; }
.q-name { font-size: 12px; font-weight: 600; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.q-item.active .q-name { color: var(--white); }
.q-meta { font-size: 10px; color: var(--text3); margin-top: 2px; display: flex; gap: 5px; align-items: center; flex-wrap: wrap; }
.qdot { width: 6px; height: 6px; border-radius: 50%; flex-shrink: 0; background: var(--border2); }
.qdot.solved     { background: var(--neon); box-shadow: 0 0 4px var(--neon); }
.qdot.active     { background: var(--cyan); animation: dotPulse 1.5s ease-in-out infinite; }
.qdot.terminated { background: var(--red); }
@keyframes dotPulse { 0%,100%{opacity:1;} 50%{opacity:0.3;} }
.q-diff-badge { font-size: 9px; padding: 1px 5px; border-radius: 3px; font-weight: 700; }
.q-diff-badge.Easy   { color: var(--neon); background: var(--neon-dim); }
.q-diff-badge.Medium { color: var(--cyan); background: var(--cyan-dim); }
.q-diff-badge.Hard   { color: var(--red);  background: var(--red-dim);  }
.q-sidebar-foot { padding: 11px 14px; border-top: 1px solid var(--border); flex-shrink: 0; }
.q-bar { height: 4px; background: var(--bg4); border-radius: 2px; overflow: hidden; margin-bottom: 6px; }
.q-bar-fill { height: 100%; background: var(--neon); border-radius: 2px; transition: width 0.5s ease; box-shadow: 0 0 6px var(--neon-glow); }
.q-bar-label { font-size: 10px; color: var(--text3); text-align: center; }

/* EDITOR + OUTPUT */
.editor-output { flex: 1; display: flex; overflow: hidden; min-width: 0; }
.editor-pane { flex: 1.3; display: flex; flex-direction: column; border-right: 1px solid var(--border); min-width: 0; }
.pane-head { display: flex; align-items: center; justify-content: space-between; padding: 9px 16px; background: var(--bg2); border-bottom: 1px solid var(--border); flex-shrink: 0; }
.pane-title { font-size: 10px; font-weight: 700; color: var(--text3); text-transform: uppercase; letter-spacing: 1.5px; display: flex; align-items: center; gap: 8px; }
.pdot { width: 7px; height: 7px; border-radius: 50%; background: var(--neon); box-shadow: 0 0 5px var(--neon-glow); }
#monaco-editor { flex: 1; min-height: 0; }
.output-pane { width: 340px; flex-shrink: 0; display: flex; flex-direction: column; background: var(--bg); }
.out-tabs { display: flex; border-bottom: 1px solid var(--border); background: var(--bg2); flex-shrink: 0; }
.out-tab { padding: 9px 14px; font-size: 10px; font-weight: 700; color: var(--text3); cursor: pointer; border: none; border-bottom: 2px solid transparent; background: none; transition: all 0.15s; text-transform: uppercase; letter-spacing: 1.5px; font-family: var(--font-ui); }
.out-tab.active { color: var(--neon); border-bottom-color: var(--neon); }
.out-pane { flex: 1; overflow-y: auto; padding: 14px; font-family: var(--font-mono); font-size: 12px; line-height: 1.7; color: var(--text2); }
.out-pane.hidden { display: none; }
.out-pane pre { white-space: pre-wrap; word-break: break-all; margin: 0; }
.res-card { margin: 12px; padding: 16px; border-radius: var(--r2); border: 1px solid; }
.res-card.pass { background: var(--neon-dim); border-color: rgba(0,245,160,0.2); }
.res-card.fail { background: var(--red-dim);  border-color: rgba(255,45,85,0.2); }
.res-icon  { font-size: 28px; display: block; margin-bottom: 8px; }
.res-label { font-family: var(--font-display); font-size: 16px; font-weight: 700; color: var(--white); }
.res-sub   { font-size: 12px; color: var(--text3); margin-top: 4px; }
.cmp-wrap  { padding: 0 12px 12px; }
.cmp-lbl   { font-size: 9px; font-weight: 700; color: var(--text3); text-transform: uppercase; letter-spacing: 2px; margin-bottom: 5px; display: block; }
.cmp-box   { background: var(--bg3); border: 1px solid var(--border2); border-radius: 5px; padding: 8px 12px; font-family: var(--font-mono); font-size: 11px; color: var(--text2); max-height: 68px; overflow-y: auto; white-space: pre-wrap; margin-bottom: 10px; }
.cmp-box.exp { border-color: rgba(0,245,160,0.2); }
.cmp-box.act { border-color: rgba(255,45,85,0.2); }
.eval-note { margin: 0 12px 12px; padding: 9px 13px; border-radius: var(--r); background: var(--purple-dim); border: 1px solid rgba(191,90,242,0.2); font-size: 11px; color: var(--purple); display: flex; align-items: center; gap: 7px; }
</style>
</head>
<body class="session-page">
<div class="bg-mesh" style="opacity:0.12;"></div>

<!-- PRE-SESSION PROMPT -->
<div id="fs-prompt">
  <div class="fs-icon">
    <svg width="72" height="72" viewBox="0 0 24 24" fill="none" stroke="var(--text3)" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"><path d="M4 5h16v11H4z"/><path d="M8 21h8"/><path d="M12 16v5"/></svg>
  </div>
  <div class="fs-title">ENTERING ARENA</div>
  <div class="fs-sub">Read the rules carefully before starting your session</div>
  <div class="fs-rules">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--red)" stroke-width="2" style="vertical-align:-2px;"><path d="M12 9v4"/><path d="M12 17h.01"/><path d="M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/></svg>
    Tab switch → <span>5-second confirmation</span> → Auto-terminate if ignored<br>
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--text2)" stroke-width="2" style="vertical-align:-2px;"><path d="M4 5h16v11H4z"/><path d="M8 21h8"/><path d="M12 16v5"/></svg>
    Session runs in <span>fullscreen</span> — do not exit<br>
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--yellow)" stroke-width="2" style="vertical-align:-2px;"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
    <span>Round timer</span> starts when you click START SESSION<br>
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--purple)" stroke-width="2" style="vertical-align:-2px;"><path d="M22 2L11 13"/><path d="M22 2L15 22 11 13 2 9l20-7z"/></svg>
    Your code is <span>sent to admin</span> on every submission<br>
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--cyan)" stroke-width="2" style="vertical-align:-2px;"><path d="M7 7h10"/><path d="M7 12h10"/><path d="M7 17h10"/><path d="M3 5h1"/><path d="M3 12h1"/><path d="M3 19h1"/></svg>
    Switch between questions using the <span>left sidebar</span>
  </div>
  <button class="fs-start" id="fs-start-btn" onclick="beginSession()">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><polygon points="5 3 19 12 5 21 5 3"/></svg>
    START SESSION
  </button>
</div>

<!-- TAB-SWITCH CONFIRMATION (Feature 1) -->
<div id="tab-confirm-overlay">
  <div class="tab-confirm-box">
    <span class="tc-icon">
      <svg width="56" height="56" viewBox="0 0 24 24" fill="none" stroke="var(--red)" stroke-width="2"><path d="M12 9v4"/><path d="M12 17h.01"/><path d="M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/></svg>
    </span>
    <div class="tc-title">TAB SWITCH DETECTED</div>
    <div class="tc-msg">You navigated away from the session.<br>Do you want to <strong>terminate</strong> your session?</div>
    <div class="tc-ring-wrap">
      <div class="tc-ring-label">Auto-terminates in</div>
      <div class="tc-ring" id="tc-ring"><span class="tc-ring-num" id="tc-num">5</span></div>
    </div>
    <div class="tc-btns">
      <button class="tc-ok"     onclick="confirmTerminate()">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>
        Yes, Terminate
      </button>
      <button class="tc-cancel" onclick="cancelTerminate()">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 14l-4-4 4-4"/><path d="M5 10h11a4 4 0 0 1 0 8h-1"/></svg>
        No, Continue
      </button>
    </div>
  </div>
</div>

<!-- TERMINATION OVERLAY -->
<div id="term-overlay">
  <div class="term-scanline"></div>
  <div class="term-icon">
    <svg width="86" height="86" viewBox="0 0 24 24" fill="none" stroke="var(--red)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M15 9l-6 6"/><path d="M9 9l6 6"/></svg>
  </div>
  <div class="term-title">SESSION TERMINATED</div>
  <div class="term-reason-box" id="term-reason-box">Session ended</div>
  <div class="term-sub-txt">Your session has been permanently ended and all submitted code has been recorded.</div>
  <div class="term-eval-note">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13"/><path d="M22 2L15 22 11 13 2 9l20-7z"/></svg>
    Your code has been sent to admin for evaluation
  </div>
  <button class="term-back" onclick="window.location.href='participant.html'">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5"/><path d="M12 19l-7-7 7-7"/></svg>
    Return to Dashboard
  </button>
</div>

<!-- COMPLETE OVERLAY -->
<div id="complete-overlay">
  <span style="font-size:76px;display:flex;align-items:center;justify-content:center;" id="co-icon"></span>
  <div style="font-family:var(--font-display);font-size:24px;font-weight:900;color:var(--white);letter-spacing:2px;" id="co-title">COMPLETE</div>
  <div style="font-size:13px;color:var(--text3);max-width:340px;line-height:1.7;" id="co-msg"></div>
  <div id="co-result" style="margin:12px 0;"></div>
  <div style="font-size:11px;color:var(--purple);background:var(--purple-dim);border:1px solid rgba(191,90,242,0.2);border-radius:var(--r2);padding:9px 20px;">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align:-2px;"><path d="M22 2L11 13"/><path d="M22 2L15 22 11 13 2 9l20-7z"/></svg>
    All submitted code has been sent to admin for evaluation
  </div>
  <button class="btn btn-neon" onclick="window.location.href='participant.html'" style="margin-top:8px;">
    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5"/><path d="M12 19l-7-7 7-7"/></svg>
    Back to Arena
  </button>
</div>

<!-- SESSION UI -->
<div id="session-ui">
  <!-- TOP BAR -->
  <div class="sess-topbar">
    <div class="sess-left">
      <div class="sess-prob-icon">
        <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
      </div>
      <div>
        <div class="sess-prob-name" id="s-title">Loading...</div>
        <div class="sess-prob-meta" id="s-meta">—</div>
      </div>
    </div>
    <div class="sess-center">
      <div class="timer-block">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="var(--text3)" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
        <span style="font-size:9px;color:var(--text3);text-transform:uppercase;letter-spacing:1.5px;">TIME</span>
        <span class="timer-val" id="timer-val">--:--</span>
      </div>
    </div>
    <div class="sess-right">
      <span class="round-badge-top" id="round-chip"></span>
      <button class="run-btn" id="run-btn" onclick="runCode()">
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
        RUN &amp; SUBMIT
      </button>
      <button class="exit-btn" onclick="exitManual()">Exit</button>
    </div>
  </div>

  <!-- INFO STRIP -->
  <div class="info-strip" id="info-strip"></div>

  <!-- BODY -->
  <div class="sess-body">
    <!-- QUESTION SIDEBAR -->
    <div class="q-sidebar">
      <div class="q-sidebar-head">
        <span>Questions</span>
        <span class="q-progress-mini" id="q-prog-mini">0/0</span>
      </div>
      <div class="q-list" id="q-list"></div>
      <div class="q-sidebar-foot">
        <div class="q-bar"><div class="q-bar-fill" id="q-bar-fill" style="width:0%"></div></div>
        <div class="q-bar-label" id="q-bar-label">0 of 0 solved</div>
      </div>
    </div>

    <!-- EDITOR + OUTPUT -->
    <div class="editor-output">
      <div class="editor-pane">
        <div class="pane-head">
          <span class="pane-title"><span class="pdot"></span> EDITOR — FIX THE BUG</span>
          <span id="lang-chip" style="font-family:var(--font-mono);font-size:11px;color:var(--text3);"></span>
        </div>
        <div id="monaco-editor"></div>
      </div>
      <div class="output-pane">
        <div class="out-tabs">
          <button class="out-tab active" onclick="switchTab('output')"   id="ot-output">Output</button>
          <button class="out-tab"        onclick="switchTab('expected')" id="ot-expected">Expected</button>
          <button class="out-tab"        onclick="switchTab('result')"   id="ot-result">Result</button>
        </div>
        <div id="op-output"   class="out-pane"><div style="color:var(--text3);font-size:13px;padding:4px 0;">Hit <strong style="color:var(--neon);font-family:var(--font-mono);">Run &amp; Submit</strong> to see output</div></div>
        <div id="op-expected" class="out-pane hidden">
          <span class="cmp-lbl" style="display:block;margin-bottom:8px;">Expected Output</span>
          <div class="cmp-box exp" id="exp-box"></div>
          <div style="font-size:11px;color:var(--text3);margin-top:8px;line-height:1.6;">Your fixed code output must exactly match this (whitespace trimmed).</div>
        </div>
        <div id="op-result" class="out-pane hidden" style="padding:0;overflow-y:auto;">
          <div id="result-area" style="padding:14px;color:var(--text3);font-size:13px;">Submit code to see results.</div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Pyodide for Python execution -->
<script src="https://cdn.jsdelivr.net/pyodide/v0.25.1/full/pyodide.js"></script>
<!-- JSCPP loaded dynamically in JS with fallback CDNs -->
<script>var require = { paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' } };</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
<script src="app.js"></script>
<script>
/* ============================================================
   DEBUGARENA SESSION v3 — Supabase Edition
   Feature 1: Tab switch → 5s countdown dialog → auto-terminate
   Feature 2: Every submission sends code to admin_submissions
   Feature 3: Problem time limit is optional; round limit mandatory
   Feature 4: Left sidebar for switching between questions
   ============================================================ */

Auth.check('participant');
const ME    = Auth.user();
const ROUND = parseInt(sessionStorage.getItem('da_round') || sessionStorage.getItem('current_round') || '1');
const _START_PROBLEM_ID = sessionStorage.getItem('da_problem_id') || sessionStorage.getItem('current_problem') || null;

const LANG_MONO  = { C: 'c', Python: 'python' };

// ── IN-BROWSER COMPILER ENGINE ────────────────────────────────
let _pyodide = null;
let _pyodideLoading = false;
let _pyodideReady = false;

async function _loadPyodide() {
  if (_pyodideReady) return _pyodide;
  if (_pyodideLoading) {
    // Wait for it to finish loading
    while (_pyodideLoading) await new Promise(r => setTimeout(r, 100));
    return _pyodide;
  }
  _pyodideLoading = true;
  try {
    _pyodide = await loadPyodide({ indexURL: 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/' });
    _pyodideReady = true;
  } catch(e) {
    console.error('Pyodide load error:', e);
  } finally {
    _pyodideLoading = false;
  }
  return _pyodide;
}

// Pre-load Pyodide in background when session starts
function _prewarmPyodide() {
  setTimeout(() => _loadPyodide().catch(() => {}), 500);
}

async function executeCode(language, sourceCode) {
  if (language === 'Python') {
    return await _executePython(sourceCode);
  } else if (language === 'C') {
    return await _executeC(sourceCode);
  }
  return { stdout: '', stderr: 'Unsupported language: ' + language };
}

async function _executePython(code) {
  try {
    const py = await _loadPyodide();
    if (!py) return { stdout: '', stderr: 'Python runtime failed to load. Please refresh.' };

    let stdout = '';
    let stderr = '';

    // Redirect stdout/stderr
    py.setStdout({ batched: (s) => { stdout += s + '\n'; } });
    py.setStderr({ batched: (s) => { stderr += s + '\n'; } });

    try {
      await py.runPythonAsync(code);
    } catch (e) {
      stderr = '__BUG_NOT_FIXED__';
    }

    // Trim trailing newline added by batched
    stdout = stdout.replace(/\n$/, '');
    stderr = stderr.replace(/\n$/, '');
    return { stdout, stderr };
  } catch(e) {
    return { stdout: '', stderr: 'Python execution error: ' + e.message };
  }
}

// ── C SYNTAX VALIDATOR ───────────────────────────────────────
function _validateCSyntax(code) {
  // 1. Check balanced braces/parens/brackets
  let braces=0, parens=0, brackets=0;
  let inStr=false, inChar=false, inLC=false, inBC=false;
  for(let i=0;i<code.length;i++){
    const c=code[i],n=code[i+1]||'';
    if(inLC){if(c==='\n')inLC=false;continue;}
    if(inBC){if(c==='*'&&n=='/'){inBC=false;i++;}continue;}
    if(inStr){if(c==='\\')i++;else if(c==='"')inStr=false;continue;}
    if(inChar){if(c==='\\')i++;else if(c==="'")inChar=false;continue;}
    if(c==='/'&&n==='/')  {inLC=true;continue;}
    if(c==='/'&&n==='*')  {inBC=true;continue;}
    if(c==='"'){inStr=true;continue;}
    if(c==="'"){inChar=true;continue;}
    if(c==='{')braces++;
    else if(c==='}'){braces--;if(braces<0)return 'Unmatched }';}
    else if(c==='(')parens++;
    else if(c===')'){parens--;if(parens<0)return 'Unmatched )';}
    else if(c==='[')brackets++;
    else if(c===']'){brackets--;if(brackets<0)return 'Unmatched ]';}
  }
  if(braces!==0)  return 'Unmatched {';
  if(parens!==0)  return 'Unmatched (';
  if(brackets!==0)return 'Unmatched [';

  // 2. Extract all function bodies and validate line by line
  let depth=0,bodyStart=-1;
  inStr=false;inChar=false;inLC=false;inBC=false;
  for(let i=0;i<code.length;i++){
    const c=code[i],n=code[i+1]||'';
    if(inLC){if(c==='\n')inLC=false;continue;}
    if(inBC){if(c==='*'&&n=='/'){inBC=false;i++;}continue;}
    if(inStr){if(c==='\\')i++;else if(c==='"')inStr=false;continue;}
    if(inChar){if(c==='\\')i++;else if(c==="'")inChar=false;continue;}
    if(c==='/'&&n==='/')  {inLC=true;continue;}
    if(c==='/'&&n==='*')  {inBC=true;continue;}
    if(c==='"'){inStr=true;continue;}
    if(c==="'"){inChar=true;continue;}
    if(c==='{'){depth++;if(depth===1)bodyStart=i+1;}
    else if(c==='}'){
      if(depth===1&&bodyStart>=0){
        const err=_validateBody(code.slice(bodyStart,i));
        if(err)return err;
        bodyStart=-1;
      }
      depth--;
    }
  }
  return null;
}

function _validateBody(body) {
  // Strip string and char literals to avoid false positives inside them
  const clean = body
    .replace(/"(?:[^"\\]|\\.)*"/g, s => '"' + ' '.repeat(Math.max(0,s.length-2)) + '"')
    .replace(/'(?:[^'\\]|\\.)*'/g, s => "'" + ' '.repeat(Math.max(0,s.length-2)) + "'");

  // Recursively validate all { } blocks inside this body
  let depth=0, blockStart=-1;
  for(let i=0;i<clean.length;i++){
    if(clean[i]==='{'){
      depth++;
      if(depth===1) blockStart=i+1;
    } else if(clean[i]==='}'){
      if(depth===1 && blockStart>=0){
        // Validate the content of this nested block
        const inner = body.slice(blockStart, i); // use original (not clean) for recursion
        const err = _validateBody(inner);
        if(err) return err;
        blockStart=-1;
      }
      depth--;
    }
  }

  // Now validate lines at THIS level (not inside any { })
  // Build a version with all { } blocks removed (replaced by placeholder)
  let flat = '';
  depth=0;
  for(let i=0;i<clean.length;i++){
    if(clean[i]==='{'){depth++;flat+=' ';}
    else if(clean[i]==='}'){depth--;flat+=' ';}
    else if(depth===0){flat+=clean[i];}
    // Skip content inside blocks (already validated recursively)
  }

  const lines = flat.split('\n').map(l=>l.trim()).filter(Boolean);

  for(const line of lines){
    if(line.endsWith(';'))  continue;
    if(line.endsWith('{'))  continue;
    if(line.endsWith('}'))  continue;
    if(line.endsWith(','))  continue;
    if(line.startsWith('//')) continue;
    if(line.startsWith('#'))  continue;

    // Control flow without block (e.g. if(...) or for(...;...;...) before next line's {)
    if(/^(if|else\s+if|for|while)\s*\(.*\)\s*$/.test(line)) continue;
    if(/^(else|do)\s*$/.test(line)) continue;
    // Single-line control + statement (e.g. "if(x>0) return x;" or "else return 0;") - has ; at end checked above

    const looksLikeStatement = (
      /=/.test(line)              ||
      /\w\s*\(/.test(line)        ||
      /\+\+|--/.test(line)        ||
      /^(int|char|float|double|long|short|unsigned|const)\s+\w/.test(line) ||
      /^return\b/.test(line)
    );
    const isControlFlow = /^(if|else|for|while|do|switch)\b/.test(line);
    const isFuncDef     = /^\w[\w\s\*]+\s+\w+\s*\([^)]*\)\s*$/.test(line);
    const isLabel       = /^\w+\s*:$/.test(line);

    if(looksLikeStatement && !isControlFlow && !isFuncDef && !isLabel){
      return 'Missing semicolon near: ' + line.replace(/\s+/g,' ').slice(0,50);
    }
  }
  return null;
}

function _findBraceEnd(s, start) {
  let d=0,i=start,inStr=false,inChar=false;
  while(i<s.length){
    const c=s[i];
    if(inStr){if(c==='\\')i++;else if(c==='"')inStr=false;i++;continue;}
    if(inChar){if(c==='\\')i++;else if(c==="'")inChar=false;i++;continue;}
    if(c==='"'){inStr=true;i++;continue;}
    if(c==="'"){inChar=true;i++;continue;}
    if(c==='{')d++;
    else if(c==='}'){d--;if(d===0)return i;}
    i++;
  }
  return s.length;
}

// ── IN-BROWSER C INTERPRETER (pure JS, no API, pass-by-ref arrays) ──
async function _executeC(code) {
  try {
    const output = _runCInterpreter(code);
    return { stdout: output.stdout, stderr: output.stderr };
  } catch(e) {
    return { stdout: '', stderr: '__BUG_NOT_FIXED__' };
  }
}

function _runCInterpreter(src) {
  // ── Preprocess ──
  let code = src
    .replace(/\/\/[^\n]*/g, '')
    .replace(/\/\*[\s\S]*?\*\//g, '')
    .replace(/#include\s*<[^>]+>/g, '')
    .replace(/#define\s+\S+[^\n]*/g, '')
    .trim();

  // ── SYNTAX VALIDATOR ──
  // Validates that every statement inside function bodies ends with ; or is a block
  // This catches missing semicolons like: food_string[i] = 'e'  (no semicolon)
  const syntaxError = _validateCSyntax(code);
  if (syntaxError) return { stdout: '', stderr: '__BUG_NOT_FIXED__' };

  let _stdout = '';
  let _callDepth = 0;
  const MAX_DEPTH = 200;
  const MAX_STEPS = 200000;
  let _steps = 0;

  // ── HEAP: arrays/strings stored as {cells:[...]} objects so they pass by ref ──
  function makeCharArray(str) {
    const cells = str.split('').map(c => c.charCodeAt(0));
    cells.push(0);
    return { cells };
  }
  function makeIntArray(size) {
    return { cells: new Array(size).fill(0) };
  }
  function readArray(obj) {
    if (!obj || !obj.cells) return '';
    let s = '';
    for (const c of obj.cells) { if (c === 0) break; s += String.fromCharCode(c); }
    return s;
  }
  function isHeapObj(v) { return v !== null && typeof v === 'object' && Array.isArray(v.cells); }

  // ── Parse all top-level functions ──
  const functions = {};
  const funcRe = /(\w[\w\s\*]*?)\s+(\w+)\s*\(([^)]*)\)\s*\{/g;
  let match;
  const funcStarts = [];
  while ((match = funcRe.exec(code)) !== null) {
    funcStarts.push({ name: match[2], params: match[3], retType: match[1].trim(), bodyStart: match.index + match[0].length });
  }
  for (let i = 0; i < funcStarts.length; i++) {
    const f = funcStarts[i];
    const bodyEnd = _findMatchingBrace(code, f.bodyStart - 1);
    const body = code.slice(f.bodyStart, bodyEnd);
    functions[f.name] = { params: f.params, body, retType: f.retType };
  }

  // ── Scopes ──
  function newScope(parent) { return { __parent__: parent, __vars__: {} }; }
  function getVar(scope, name) {
    let s = scope;
    while (s) { if (name in s.__vars__) return s.__vars__[name]; s = s.__parent__; }
    return undefined;
  }
  function setVar(scope, name, val) {
    let s = scope;
    while (s) { if (name in s.__vars__) { s.__vars__[name] = val; return; } s = s.__parent__; }
    scope.__vars__[name] = val;
  }
  function declVar(scope, name, val) { scope.__vars__[name] = val; }

  // ── Expressions ──
  function evalExpr(expr, scope) {
    if (++_steps > MAX_STEPS) throw new Error('timeout');
    expr = expr.trim();
    if (!expr) return 0;

    if (/^"([^"]*)"$/.test(expr)) {
      const raw = expr.slice(1,-1).replace(/\\n/g,'\n').replace(/\\t/g,'\t').replace(/\\0/g,'\0').replace(/\\r/g,'\r');
      return makeCharArray(raw);
    }
    if (expr === "'\\0'") return 0;
    if (expr === "'\\n'") return 10;
    if (expr === "'\\t'") return 9;
    if (/^'\\?.'$/.test(expr)) return expr.charCodeAt(expr.length === 3 ? 1 : 2);
    if (/^-?\d+(\.\d+)?$/.test(expr)) return parseFloat(expr);

    if (expr[0]==='('&&_findClose(expr,0,'(',')')===expr.length-1) return evalExpr(expr.slice(1,-1),scope);

    // Ternary
    const tern = _splitTernary(expr);
    if (tern) return evalExpr(tern.cond,scope) ? evalExpr(tern.t,scope) : evalExpr(tern.f,scope);

    // Compound assignment
    for (const op of ['+=','-=','*=','/=','%=']) {
      const idx = _rfindOp(expr, op);
      if (idx > 0) {
        const lhs = expr.slice(0,idx).trim(), rhs = evalExpr(expr.slice(idx+op.length),scope);
        const cur = evalLVal(lhs,scope);
        const ops = {'+=':(a,b)=>a+b,'-=':(a,b)=>a-b,'*=':(a,b)=>a*b,'/=':(a,b)=>Math.trunc(a/b),'%=':(a,b)=>a%b};
        const nv = ops[op](Number(cur),Number(rhs));
        assignLVal(lhs,nv,scope); return nv;
      }
    }
    // Assignment
    const asgn = _rfindAssign(expr);
    if (asgn > 0) {
      const lhs = expr.slice(0,asgn).trim(), rhs = evalExpr(expr.slice(asgn+1),scope);
      assignLVal(lhs,rhs,scope); return rhs;
    }

    // Logical OR/AND
    const orI = _splitBinary(expr,'||'); if(orI>=0) return (evalExpr(expr.slice(0,orI),scope)||evalExpr(expr.slice(orI+2),scope))?1:0;
    const anI = _splitBinary(expr,'&&'); if(anI>=0) return (evalExpr(expr.slice(0,anI),scope)&&evalExpr(expr.slice(anI+2),scope))?1:0;

    // Comparison
    for (const op of ['==','!=','<=','>=','<','>']) {
      const idx = _splitBinary(expr,op);
      if (idx>=0) {
        const l=evalExpr(expr.slice(0,idx),scope), r=evalExpr(expr.slice(idx+op.length),scope);
        const lv=isHeapObj(l)?readArray(l):l, rv=isHeapObj(r)?readArray(r):r;
        const cmp={'==':(a,b)=>a==b,'!=':(a,b)=>a!=b,'<=':(a,b)=>a<=b,'>=':(a,b)=>a>=b,'<':(a,b)=>a<b,'>':(a,b)=>a>b};
        return cmp[op](lv,rv)?1:0;
      }
    }

    // Additive / subtractive
    const add = _splitBinaryAddSub(expr);
    if (add!==null) {
      const l=evalExpr(expr.slice(0,add.idx),scope), r=evalExpr(expr.slice(add.idx+1),scope);
      return add.op==='+' ? Number(l)+Number(r) : Number(l)-Number(r);
    }

    // Multiplicative
    for (const op of ['*','/',  '%']) {
      const idx = _splitBinary(expr,op);
      if (idx>0) {
        const l=evalExpr(expr.slice(0,idx),scope),r=evalExpr(expr.slice(idx+1),scope);
        if(op==='*')return Number(l)*Number(r);
        if(op==='/')return Math.trunc(Number(l)/Number(r));
        if(op==='%')return Number(l)%Number(r);
      }
    }

    if(expr[0]==='!'&&expr.length>1) return evalExpr(expr.slice(1),scope)?0:1;
    if(expr[0]==='-'&&expr.length>1&&!/^\d/.test(expr[1])) return -Number(evalExpr(expr.slice(1),scope));

    // Unary * dereference: get first element
    if(expr[0]==='*'&&expr.length>1){
      const inner=evalExpr(expr.slice(1),scope);
      if(isHeapObj(inner)) return inner.cells[0]??0;
      return inner;
    }

    // Pre-increment/decrement
    if(expr.startsWith('++')){ const v=Number(evalLVal(expr.slice(2),scope))+1; assignLVal(expr.slice(2),v,scope); return v; }
    if(expr.startsWith('--')){ const v=Number(evalLVal(expr.slice(2),scope))-1; assignLVal(expr.slice(2),v,scope); return v; }
    // Post-increment/decrement
    if(expr.endsWith('++')){ const lv=expr.slice(0,-2).trim(); const v=evalLVal(lv,scope); assignLVal(lv,Number(v)+1,scope); return v; }
    if(expr.endsWith('--')){ const lv=expr.slice(0,-2).trim(); const v=evalLVal(lv,scope); assignLVal(lv,Number(v)-1,scope); return v; }

    if(/^sizeof\s*\(/.test(expr)) return 4;

    // Array subscript: name[idx]
    const subMatch = expr.match(/^(\w+)\[(.+)\]$/);
    if (subMatch) {
      const arr = getVar(scope, subMatch[1]);
      const idx = Math.trunc(Number(evalExpr(subMatch[2],scope)));
      if (isHeapObj(arr)) return arr.cells[idx]??0;
      return 0;
    }

    // Function call
    const callMatch = expr.match(/^(\w+)\s*\(([\s\S]*)\)\s*$/);
    if (callMatch) {
      const fname=callMatch[1], argsStr=callMatch[2];
      const argVals=_splitArgs(argsStr).map(a=>evalExpr(a.trim(),scope));
      const bi=callBuiltin(fname,argVals,scope);
      return bi!==undefined ? bi : callUser(fname,argVals,scope);
    }

    // Cast
    const castMatch = expr.match(/^\((?:int|char|float|double|long|short|unsigned[\w\s]*|void\s*\*|\w+\s*\*?)\)\s*(.+)$/);
    if (castMatch) return evalExpr(castMatch[1],scope);

    if(expr.includes('->')||( expr.includes('.')&&!/^\d+\.\d+$/.test(expr))) return 0;

    const v = getVar(scope, expr);
    if (v !== undefined) return v;
    return 0;
  }

  function evalLVal(expr, scope) {
    expr = expr.trim();
    const subMatch = expr.match(/^(\w+)\[(.+)\]$/);
    if (subMatch) {
      const arr = getVar(scope, subMatch[1]);
      const idx = Math.trunc(Number(evalExpr(subMatch[2],scope)));
      if (isHeapObj(arr)) return arr.cells[idx]??0;
      return 0;
    }
    const v = getVar(scope, expr);
    return v !== undefined ? v : 0;
  }

  function assignLVal(expr, val, scope) {
    expr = expr.trim();
    // Array subscript: mutate the heap object in-place (pass-by-ref semantics)
    const subMatch = expr.match(/^(\w+)\[(.+)\]$/);
    if (subMatch) {
      const arr = getVar(scope, subMatch[1]);
      const idx = Math.trunc(Number(evalExpr(subMatch[2],scope)));
      if (isHeapObj(arr)) {
        arr.cells[idx] = typeof val === 'string' ? val.charCodeAt(0) : Math.trunc(Number(val));
      }
      return;
    }
    // Unary dereference: *ptr = val — mutate first cell
    if (expr[0]==='*') {
      const ptr = evalExpr(expr.slice(1), scope);
      if (isHeapObj(ptr)) ptr.cells[0] = typeof val==='string'?val.charCodeAt(0):Math.trunc(Number(val));
      return;
    }
    setVar(scope, expr, val);
  }

  // ── Built-ins ──
  function callBuiltin(name, args, scope) {
    if (name==='printf')  { _stdout += _printf(_valToString(args[0]), args.slice(1)); return 0; }
    if (name==='puts')    { _stdout += _valToString(args[0])+'\n'; return 0; }
    if (name==='putchar') { const c=args[0]; _stdout+=typeof c==='number'?String.fromCharCode(c):String(c); return c; }
    if (name==='strlen')  { return _valToString(args[0]).length; }
    if (name==='strcmp')  { const a=_valToString(args[0]),b=_valToString(args[1]); return a<b?-1:a>b?1:0; }
    if (name==='strcpy')  { if(isHeapObj(args[0])&&isHeapObj(args[1])){ args[0].cells=[...args[1].cells]; } return args[0]; }
    if (name==='strcat')  { if(isHeapObj(args[0])&&isHeapObj(args[1])){ const s=readArray(args[0])+readArray(args[1]); args[0].cells=makeCharArray(s).cells; } return args[0]; }
    if (name==='strncpy') { if(isHeapObj(args[0])&&isHeapObj(args[1])){ const s=readArray(args[1]).slice(0,args[2]); args[0].cells=makeCharArray(s).cells; } return args[0]; }
    if (name==='abs'||name==='fabs') return Math.abs(Number(args[0]));
    if (name==='sqrt')  return Math.sqrt(Number(args[0]));
    if (name==='pow')   return Math.pow(Number(args[0]),Number(args[1]));
    if (name==='floor') return Math.floor(Number(args[0]));
    if (name==='ceil')  return Math.ceil(Number(args[0]));
    if (name==='round') return Math.round(Number(args[0]));
    if (name==='scanf'||name==='fscanf'||name==='sscanf') return 0;
    if (name==='malloc'||name==='calloc') return makeIntArray(Number(args[0])||64);
    if (name==='free')  return 0;
    if (name==='exit')  throw {__exit__: args[0]??0};
    if (name==='atoi')  return parseInt(_valToString(args[0]))||0;
    if (name==='isalpha') { const c=Number(args[0]); return (c>=65&&c<=90)||(c>=97&&c<=122)?1:0; }
    if (name==='isdigit') { const c=Number(args[0]); return c>=48&&c<=57?1:0; }
    if (name==='islower') { const c=Number(args[0]); return c>=97&&c<=122?1:0; }
    if (name==='isupper') { const c=Number(args[0]); return c>=65&&c<=90?1:0; }
    if (name==='tolower') { const c=Number(args[0]); return c>=65&&c<=90?c+32:c; }
    if (name==='toupper') { const c=Number(args[0]); return c>=97&&c<=122?c-32:c; }
    return undefined;
  }

  function callUser(name, argVals, parentScope) {
    if (!functions[name]) return 0;
    if (++_callDepth > MAX_DEPTH) throw new Error('stack overflow');
    const fn = functions[name];
    const scope = newScope(null);
    const params = fn.params.split(',').map(p=>p.trim()).filter(Boolean);
    params.forEach((p,i) => {
      const pname = p.replace(/\*/g,'').replace(/\[\]/g,'').trim().split(/\s+/).pop();
      // Arrays/heap objects are passed by reference (same object reference)
      declVar(scope, pname, argVals[i]!==undefined ? argVals[i] : 0);
    });
    try {
      const ret = execBlock(fn.body, scope);
      _callDepth--;
      if (ret && ret.__return__ !== undefined) return ret.__return__;
      return 0;
    } catch(e) {
      _callDepth--;
      if (e && e.__exit__!==undefined) throw e;
      throw e;
    }
  }

  // ── Statement executor ──
  function execBlock(code, scope) {
    const stmts = _parseStatements(code);
    for (const stmt of stmts) {
      if (++_steps > MAX_STEPS) throw new Error('timeout');
      const r = execStmt(stmt.trim(), scope);
      if (r && (r.__return__!==undefined || r.__break__ || r.__continue__)) return r;
    }
    return null;
  }

  function execStmt(stmt, scope) {
    if (!stmt || stmt===';') return null;

    if (stmt[0]==='{') {
      const inner = stmt.slice(1, _findMatchingBrace(stmt,0));
      return execBlock(inner, newScope(scope));
    }

    if (/^return\b/.test(stmt)) {
      const val = evalExpr(stmt.slice(6).replace(/;$/,'').trim(), scope);
      return {__return__: val};
    }
    if (/^break\s*;?$/.test(stmt))    return {__break__: true};
    if (/^continue\s*;?$/.test(stmt)) return {__continue__: true};

    if (/^if\s*\(/.test(stmt)) {
      const {cond,body,rest} = _parseIf(stmt);
      if (evalExpr(cond,scope)) {
        const r = execStmt(body, newScope(scope)); if(r) return r;
      } else if (rest) {
        const r = execStmt(rest.replace(/^else\s*/,''), newScope(scope)); if(r) return r;
      }
      return null;
    }

    if (/^while\s*\(/.test(stmt)) {
      const {cond,body} = _parseWhile(stmt);
      let iters=0;
      while (evalExpr(cond,scope)) {
        if(++iters>50000) break;
        const r=execStmt(body,newScope(scope));
        if(r?.__break__) break;
        if(r?.__return__!==undefined) return r;
      }
      return null;
    }

    if (/^for\s*\(/.test(stmt)) {
      const {init,cond,post,body} = _parseFor(stmt);
      const fs = newScope(scope);
      if(init) execStmt(init+';', fs);
      let iters=0;
      while (!cond || evalExpr(cond,fs)) {
        if(++iters>50000) break;
        const r=execStmt(body,newScope(fs));
        if(r?.__break__) break;
        if(r?.__return__!==undefined) return r;
        if(r?.__continue__) { post&&evalExpr(post,fs); continue; }
        post&&evalExpr(post,fs);
      }
      return null;
    }

    if (/^do\b/.test(stmt)) {
      const m=stmt.match(/^do\s*(\{[\s\S]*\})\s*while\s*\(([^)]+)\)/);
      if(m) { let iters=0; do { if(++iters>50000)break; const r=execStmt(m[1],newScope(scope)); if(r?.__break__)break; if(r?.__return__!==undefined)return r; } while(evalExpr(m[2],scope)); }
      return null;
    }

    // Variable declaration (type name = val; or type arr[n]; or type arr[] = "str"; or type *name = expr;)
    const declMatch = stmt.match(/^(?:const\s+)?(?:unsigned\s+)?(?:int|char|float|double|long|short|void)\s*(\*?)\s*(\w+)(?:\[(\d*)\])?\s*(?:=\s*([\s\S]+?))?\s*;$/);
    if (declMatch) {
      const isPtr=declMatch[1]==='*', name=declMatch[2], isArr=declMatch[3]!==undefined, initStr=declMatch[4];
      if (isArr||isPtr) {
        if (initStr) {
          const iv = evalExpr(initStr, scope);
          if (isHeapObj(iv)) { declVar(scope, name, iv); }
          else { declVar(scope, name, makeCharArray(String(iv))); }
        } else {
          const sz = declMatch[3] ? parseInt(declMatch[3])||64 : 64;
          declVar(scope, name, makeIntArray(sz));
        }
      } else {
        declVar(scope, name, initStr ? evalExpr(initStr,scope) : 0);
      }
      return null;
    }

    const exprStmt = stmt.replace(/;$/,'').trim();
    if (exprStmt) evalExpr(exprStmt, scope);
    return null;
  }

  // ── printf ──
  function _printf(fmt, args) {
    let out='', ai=0;
    for (let i=0; i<fmt.length; i++) {
      if (fmt[i]==='%') {
        i++;
        let flags='', width='', prec='';
        while('-+ #0'.includes(fmt[i])) flags+=fmt[i++];
        while(/\d/.test(fmt[i])) width+=fmt[i++];
        if(fmt[i]==='.'){i++;while(/\d/.test(fmt[i]))prec+=fmt[i++];}
        const spec=fmt[i];
        const val=args[ai++];
        if(spec==='d'||spec==='i'||spec==='u') out+=_fmtInt(val,width,flags);
        else if(spec==='f') out+=Number(val||0).toFixed(parseInt(prec)||6);
        else if(spec==='e') out+=Number(val||0).toExponential(parseInt(prec)||6);
        else if(spec==='c') out+=String.fromCharCode(typeof val==='number'?val:(val?.charCodeAt?.(0)??0));
        else if(spec==='s') out+=_valToString(val);
        else if(spec==='l'&&fmt[i+1]==='d'){out+=_fmtInt(val,width,flags);i++;}
        else if(spec==='%') out+='%';
        else out+='%'+spec;
      } else if(fmt[i]==='\\') {
        i++;
        const esc={n:'\n',t:'\t',r:'\r','0':'\0','\\':'\\','"':'"',"'":'\'',a:'\x07',b:'\x08'};
        out+=esc[fmt[i]]||fmt[i];
      } else out+=fmt[i];
    }
    return out;
  }
  function _fmtInt(v,width,flags) {
    let s=String(Math.trunc(Number(v)||0));
    if(width){const w=parseInt(width);s=flags.includes('-')?s.padEnd(w):flags.includes('0')?s.padStart(w,'0'):s.padStart(w);}
    return s;
  }
  function _valToString(v) {
    if(v===null||v===undefined) return '';
    if(isHeapObj(v)) return readArray(v);
    if(typeof v==='string') return v;
    if(typeof v==='number') return String.fromCharCode(v);
    return String(v);
  }

  // ── Parser helpers ──
  function _findMatchingBrace(s, start) {
    let d=0,i=start; while(i<s.length){if(s[i]==='{')d++;else if(s[i]==='}'){d--;if(d===0)return i;}i++;} return s.length;
  }
  function _findClose(s,start,open,close) {
    let d=0,i=start; while(i<s.length){if(s[i]===open)d++;else if(s[i]===close){d--;if(d===0)return i;}i++;} return s.length;
  }
  function _splitArgs(s) {
    const parts=[]; let depth=0,cur='',inStr=false,inChr=false;
    for(let i=0;i<s.length;i++){
      const c=s[i];
      if(inStr){ if(c==='\\'){ cur+=c+s[++i]; continue; } if(c==='"') inStr=false; cur+=c; continue; }
      if(inChr){ if(c==='\\'){ cur+=c+s[++i]; continue; } if(c==="'") inChr=false; cur+=c; continue; }
      if(c==='"'){ inStr=true; cur+=c; continue; }
      if(c==="'"){ inChr=true; cur+=c; continue; }
      if('([{'.includes(c)) depth++;
      else if(')]}'.includes(c)) depth--;
      if(c===','&&depth===0){ parts.push(cur); cur=''; }
      else cur+=c;
    }
    if(cur.trim()) parts.push(cur);
    return parts;
  }
  function _splitBinary(expr, op) {
    let depth=0,inStr=false;
    for(let i=expr.length-op.length;i>=0;i--){
      if(expr[i]==='"')inStr=!inStr;if(inStr)continue;
      if(')]}'.includes(expr[i]))depth++;if('([{'.includes(expr[i]))depth--;
      if(depth===0&&expr.slice(i,i+op.length)===op){
        const a=expr[i+op.length]||'';
        // look past spaces for the real preceding char
        let pi=i-1; while(pi>=0&&expr[pi]===' ')pi--;
        const b=expr[pi]||'';
        if(op==='='&&('!=<>=+-%*/'.includes(b)||a==='='))continue;
        if(op==='<'&&(a==='='||a==='<'))continue;
        if(op==='>'&&(a==='='||a==='>'))continue;
        if(op==='*'&&i===0)continue;
        if(op==='/'&&i===0)continue;
        return i;
      }
    }
    return -1;
  }
  function _rfindAssign(expr) {
    let depth=0,inStr=false;
    for(let i=expr.length-1;i>0;i--){
      if(expr[i]==='"')inStr=!inStr;if(inStr)continue;
      if(')]}'.includes(expr[i]))depth++;if('([{'.includes(expr[i]))depth--;
      if(depth===0&&expr[i]==='='){
        const a=expr[i+1]||'';
        let pi=i-1; while(pi>=0&&expr[pi]===' ')pi--;
        const b=expr[pi]||'';
        if('!=<>+-%*/&|^'.includes(b)||a==='=')continue;
        return i;
      }
    }
    return -1;
  }
  function _rfindOp(expr, op) {
    const idx=expr.lastIndexOf(op); if(idx<0)return -1;
    // make sure it's not part of a longer op
    const a=expr[idx+op.length]||'';
    if(a==='=')return -1;
    return idx;
  }
  function _splitBinaryAddSub(expr) {
    let depth=0,inStr=false;
    for(let i=expr.length-1;i>0;i--){
      if(expr[i]==='"')inStr=!inStr;if(inStr)continue;
      if(')]}'.includes(expr[i]))depth++;if('([{'.includes(expr[i]))depth--;
      if(depth===0&&(expr[i]==='+'||expr[i]==='-')){
        if(expr[i-1]===expr[i]||expr[i+1]===expr[i])continue;
        if(expr[i+1]==='=')continue;
        // look past spaces to find the real char before the operator
        let prev=i-1; while(prev>0&&expr[prev]===' ')prev--;
        if(/[\w)\]'"]/.test(expr[prev]))return {idx:i,op:expr[i]};
      }
    }
    return null;
  }
  function _splitTernary(expr) {
    let depth=0;
    for(let i=0;i<expr.length;i++){
      if('([{'.includes(expr[i]))depth++;if(')]}'.includes(expr[i]))depth--;
      if(depth===0&&expr[i]==='?'){
        const cond=expr.slice(0,i),rest=expr.slice(i+1);
        let d2=0;
        for(let j=0;j<rest.length;j++){
          if('([{'.includes(rest[j]))d2++;if(')]}'.includes(rest[j]))d2--;
          if(d2===0&&rest[j]===':')return{cond,t:rest.slice(0,j),f:rest.slice(j+1)};
        }
      }
    }
    return null;
  }
  function _parseStatements(code) {
    const stmts=[]; let i=0,cur='',parenDepth=0;
    while(i<code.length){
      const c=code[i];
      if(c==='"'){cur+=c;i++;while(i<code.length&&code[i]!=='"'){if(code[i]==='\\'){cur+=code[i++];}cur+=code[i++];}cur+=(code[i++]||'');}
      else if(c==="'"){cur+=c;i++;while(i<code.length&&code[i]!=="'"){if(code[i]==='\\'){cur+=code[i++];}cur+=code[i++];}cur+=(code[i++]||'');}
      else if(c==='{'){const end=_findMatchingBrace(code,i);cur+=code.slice(i,end+1);i=end+1;stmts.push(cur.trim());cur='';parenDepth=0;}
      else if(c==='('){parenDepth++;cur+=c;i++;}
      else if(c===')'){parenDepth--;cur+=c;i++;}
      else if(c===';'&&parenDepth===0){cur+=c;i++;stmts.push(cur.trim());cur='';}
      else{cur+=c;i++;}
    }
    if(cur.trim())stmts.push(cur.trim());
    return stmts.filter(Boolean);
  }
  function _parseIf(stmt) {
    const cs=stmt.indexOf('(')+1, ce=_findClose(stmt,cs-1,'(',')')
    const cond=stmt.slice(cs,ce);
    let rest=stmt.slice(ce+1).trim(), body='', elseStr='';
    if(rest[0]==='{'){const be=_findMatchingBrace(rest,0);body=rest.slice(0,be+1);elseStr=rest.slice(be+1).trim();}
    else{const semi=rest.indexOf(';');body=rest.slice(0,semi+1).trim();elseStr=rest.slice(semi+1).trim();}
    return{cond,body,rest:elseStr.startsWith('else')?elseStr:null};
  }
  function _parseWhile(stmt) {
    const cs=stmt.indexOf('(')+1, ce=_findClose(stmt,cs-1,'(',')')
    return{cond:stmt.slice(cs,ce), body:stmt.slice(ce+1).trim()};
  }
  function _parseFor(stmt) {
    const cs=stmt.indexOf('(')+1, ce=_findClose(stmt,cs-1,'(',')')
    const parts=stmt.slice(cs,ce);
    const segs=[]; let d2=0,cur2='';
    for(const c of parts){if('([{'.includes(c))d2++;if(')]}'.includes(c))d2--;if(c===';'&&d2===0){segs.push(cur2.trim());cur2='';}else cur2+=c;}
    segs.push(cur2.trim());
    return{init:segs[0]||'',cond:segs[1]||'',post:segs[2]||'',body:stmt.slice(ce+1).trim()};
  }

  // ── Run main() ──
  try { callUser('main',[],newScope(null)); }
  catch(e) { if(!e||e.__exit__===undefined) return{stdout:_stdout,stderr:'__BUG_NOT_FIXED__'}; }
  return { stdout: _stdout.replace(/\n$/,''), stderr: '' };
}

// ── State ────────────────────────────────────────────────────
let allProblems   = [];   // all active problems for this round + lang
let currentIdx    = 0;
let problem       = null;
let monacoEditor  = null;
let problemStates = {};   // { [id]: { code, outHtml, resHtml, status } }

let sessionLive      = false;
let sessionDone      = false;
let lockdownActive   = false;
let lockdownBound    = false;
let terminationFired = false;

let startTime     = null;
let timerInterval = null;
let timeLeft      = 0;

// Tab-switch dialog
let tabPending   = false;
let tabCountdown = null;
let tabSecs      = 5;

// ── INIT ─────────────────────────────────────────────────────
async function init() {
  showLoading('Loading session...');
  try {
    const [part, problems, rs, mySubs] = await Promise.all([
      DB.getParticipant(ME),
      DB.getProblems(),
      DB.getRoundState(),
      DB.getMySubmissions(ME)
    ]);

    if (!part) { window.location.href = 'participant.html'; return; }

    if ((mySubs || []).some(s => String(s.round) === String(ROUND))) {
      if (typeof Toast !== 'undefined' && Toast?.show) Toast.show('You already submitted for this round. You cannot start it again.', 'warn', 5000);
      window.location.href = 'participant.html';
      return;
    }

    const lang = ROUND === 2 ? part.round2Lang : part.round1Lang;
    if (!lang)  { window.location.href = 'participant.html'; return; }

    // Filter problems for this round + language
    allProblems = problems.filter(p =>
      p.round == ROUND && p.language === lang && p.status === 'active'
    );
    if (!allProblems.length) { window.location.href = 'participant.html'; return; }

    // Restore last viewed problem
    const lastId = _START_PROBLEM_ID || sessionStorage.getItem('current_problem');
    if (lastId) {
      const i = allProblems.findIndex(p => p.id === lastId);
      if (i >= 0) currentIdx = i;
    }
    problem = allProblems[currentIdx];

    // Init per-problem state slots
    allProblems.forEach(p => {
      problemStates[p.id] = { code: p.buggyCode, outHtml: null, resHtml: null, status: 'unsolved' };
    });

    // Load solved/terminated flags from DB
    await syncSolvedFromDB();

    // Store round state for beginSession
    window._rs = rs;

  } catch(e) {
    console.error('Init error', e);
  } finally {
    hideLoading();
  }
}

async function lockRoundAfterSubmission() {
  const sk = ROUND === 2 ? 'round2Status' : 'round1Status';
  try { await DB.updateParticipant(ME, { [sk]: 'submitted' }); } catch (e) {}
}

async function syncSolvedFromDB() {
  const subs = await DB.getMySubmissions(ME);
  const mySubs = subs.filter(s => s.round == ROUND);
  allProblems.forEach(p => {
    if (mySubs.some(s => s.problemId === p.id && s.result === 'Pass'))    problemStates[p.id].status = 'solved';
    if (mySubs.some(s => s.problemId === p.id && s.terminated === true))  problemStates[p.id].status = 'terminated';
  });
}

// ── BEGIN SESSION ─────────────────────────────────────────────
async function beginSession() {
  const btn = document.getElementById('fs-start-btn');
  btn.disabled = true; btn.textContent = 'ENTERING...';

  try { await document.documentElement.requestFullscreen(); } catch(e) {}

  document.getElementById('fs-prompt').style.display = 'none';
  document.getElementById('session-ui').classList.add('active');

  // Round timer (always mandatory)
  const rs   = window._rs || { round1TimeLimit: 30, round2TimeLimit: 45 };
  const mins = ROUND === 2 ? (rs.round2TimeLimit || 45) : (rs.round1TimeLimit || 30);
  timeLeft   = mins * 60;
  startTime  = Date.now();
  sessionLive = true;
  updateTimer();
  timerInterval = setInterval(tick, 1000);

  // Load Monaco editor
  require(['vs/editor/editor.main'], function() {
    monacoEditor = monaco.editor.create(document.getElementById('monaco-editor'), {
      value: problem.buggyCode,
      language: LANG_MONO[problem.language] || 'plaintext',
      theme: 'vs-dark',
      fontSize: 14,
      fontFamily: "'JetBrains Mono', monospace",
      lineNumbers: 'on',
      minimap: { enabled: false },
      scrollBeyondLastLine: false,
      automaticLayout: true,
      padding: { top: 14, bottom: 14 },
      cursorBlinking: 'phase',
      wordWrap: 'on',
      renderLineHighlight: 'line',
      scrollbar: { verticalScrollbarSize: 5, horizontalScrollbarSize: 5 },
    });
    loadProblemUI(currentIdx);
    buildSidebar();
  });

  setTimeout(activateLockdown, 900);
  _prewarmPyodide(); // Start loading Python runtime in background
}

// ── LOAD PROBLEM INTO UI ──────────────────────────────────────
function loadProblemUI(idx) {
  // Save current editor content before switching
  if (monacoEditor && problem && problemStates[problem.id]) {
    problemStates[problem.id].code = monacoEditor.getValue();
  }

  currentIdx = idx;
  problem    = allProblems[idx];
  sessionStorage.setItem('current_problem', problem.id);
  const st = problemStates[problem.id];

  // Topbar
  document.getElementById('s-title').textContent = problem.title;
  document.getElementById('s-meta').textContent  = `${problem.language} · Round ${ROUND} · ${ME}`;
  document.getElementById('lang-chip').textContent = problem.language;
  document.getElementById('exp-box').textContent   = problem.expectedOutput;

  // Info strip — Feature 3: time limit is optional
  const diffColors = { Easy:'var(--neon)', Medium:'var(--cyan)', Hard:'var(--red)' };
  const timeTxt = problem.timeLimit
    ? `Problem limit: <strong style="color:var(--yellow);">${problem.timeLimit} min</strong>`
    : `<span style="color:var(--text3);font-style:italic;">No per-problem limit</span>`;
  document.getElementById('info-strip').innerHTML = `
    <span>Difficulty: <strong style="color:${diffColors[problem.difficulty]||'var(--cyan)'};">${problem.difficulty||'Medium'}</strong></span>
    <span>${timeTxt}</span>
    ${problem.hint ? `<span>💡 <strong>${escapeHtml(problem.hint)}</strong></span>` : ''}
    <span style="margin-left:auto;font-size:10px;font-family:var(--font-mono);">Q${idx+1}/${allProblems.length}</span>
  `;

  // Round chip
  const rc = document.getElementById('round-chip');
  rc.textContent = `R${ROUND}`;
  Object.assign(rc.style, ROUND === 2
    ? { background:'var(--gold-dim)',  color:'var(--gold)',  border:'1px solid rgba(255,165,0,0.2)' }
    : { background:'var(--neon-dim)',  color:'var(--neon)',  border:'1px solid rgba(0,245,160,0.2)' }
  );

  // Restore editor
  if (monacoEditor) {
    monacoEditor.setValue(st.code || problem.buggyCode);
    monaco.editor.setModelLanguage(monacoEditor.getModel(), LANG_MONO[problem.language] || 'plaintext');
  }

  // Restore output/result panels
  document.getElementById('op-output').innerHTML = st.outHtml ||
    `<div style="color:var(--text3);font-size:13px;padding:4px 0;">Hit <strong style="color:var(--neon);font-family:var(--font-mono);">Run &amp; Submit</strong> to see output</div>`;
  document.getElementById('result-area').innerHTML = st.resHtml ||
    `<div style="padding:14px;color:var(--text3);font-size:13px;">Submit code to see results.</div>`;

  switchTab('output');

  // Run button state
  const btn = document.getElementById('run-btn');
  if (st.status === 'solved') {
    btn.disabled = true; btn.textContent = '✓ SOLVED';
  } else if (st.status === 'terminated') {
    btn.disabled = true; btn.textContent = '⛔ TERMINATED';
  } else {
    btn.disabled = false;
    btn.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg> RUN &amp; SUBMIT`;
  }
}

// ── SIDEBAR (Feature 4) ───────────────────────────────────────
function buildSidebar() {
  const solved = allProblems.filter(p => problemStates[p.id]?.status === 'solved').length;
  const total  = allProblems.length;
  const pct    = total ? (solved / total * 100) : 0;

  document.getElementById('q-prog-mini').textContent = `${solved}/${total}`;
  document.getElementById('q-bar-fill').style.width  = pct + '%';
  document.getElementById('q-bar-label').textContent = `${solved} of ${total} solved`;

  document.getElementById('q-list').innerHTML = allProblems.map((p, i) => {
    const st     = problemStates[p.id];
    const active = i === currentIdx;
    const cls    = active ? 'active' : st?.status === 'solved' ? 'solved' : st?.status === 'terminated' ? 'terminated' : '';
    const dotCls = active ? 'active' : st?.status === 'solved' ? 'solved' : st?.status === 'terminated' ? 'terminated' : '';
    const statLbl= active ? 'Current' : st?.status === 'solved' ? 'Solved' : st?.status === 'terminated' ? 'Terminated' : 'Unsolved';
    const timeLbl = p.timeLimit ? `${p.timeLimit}m` : '∞';
    return `<div class="q-item ${cls}" onclick="switchQuestion(${i})">
      <div class="q-num">${i+1}</div>
      <div class="q-info">
        <div class="q-name">${escapeHtml(p.title)}</div>
        <div class="q-meta">
          <span class="qdot ${dotCls}"></span>
          <span>${statLbl}</span>
          <span class="q-diff-badge ${p.difficulty||'Medium'}">${p.difficulty||'Med'}</span>
          <span style="margin-left:auto;color:var(--yellow);font-family:var(--font-mono);font-size:9px;">${timeLbl}</span>
        </div>
      </div>
    </div>`;
  }).join('');
}

function switchQuestion(idx) {
  if (idx === currentIdx || !sessionLive || sessionDone) return;
  if (problemStates[allProblems[idx].id]?.status === 'terminated') return;
  loadProblemUI(idx);
  buildSidebar();
}

// ── TIMER ─────────────────────────────────────────────────────
function tick() { timeLeft--; updateTimer(); if (timeLeft <= 0) endAllSessions('Time Up'); }
function updateTimer() {
  const el = document.getElementById('timer-val');
  el.textContent = fmtTime(timeLeft); el.className = 'timer-val';
  if (timeLeft <= 60)       el.classList.add('danger');
  else if (timeLeft <= 180) el.classList.add('warn');
}
function getElapsed() { return fmtTime(Math.floor((Date.now() - startTime) / 1000)); }

function switchTab(n) {
  ['output','expected','result'].forEach(t => {
    document.getElementById('op-' + t).classList.add('hidden');
    document.getElementById('ot-' + t).classList.remove('active');
  });
  document.getElementById('op-' + n).classList.remove('hidden');
  document.getElementById('ot-' + n).classList.add('active');
}

// ── RUN & SUBMIT ──────────────────────────────────────────────
async function runCode() {
  if (!sessionLive || sessionDone) return;
  const st = problemStates[problem.id];
  if (st.status === 'solved' || st.status === 'terminated') return;

  const code = monacoEditor?.getValue() || '';
  if (!code.trim()) { showToast('Write some code first!', 'warn'); return; }

  const btn = document.getElementById('run-btn');
  btn.disabled = true;
  btn.innerHTML = `<span class="spin"></span> Running...`;
  switchTab('output');
  document.getElementById('op-output').innerHTML =
    `<div style="display:flex;align-items:center;gap:10px;color:var(--text3);"><span class="spin"></span> Executing...</div>`;

  let stdout = '', stderr = '';
  try {
    const lang = problem.language;
    if (lang === 'Python' && !_pyodideReady) {
      document.getElementById('op-output').innerHTML =
        `<div style="display:flex;align-items:center;gap:10px;color:var(--text3);"><span class="spin"></span> Loading Python runtime (first run ~10s)...</div>`;
    }
    const result = await executeCode(lang, code);
    stdout = result.stdout || '';
    stderr = result.stderr || '';
  } catch(e) {
    stderr = 'Execution error: ' + e.message;
  }

  const outHtml = buildOutputHtml(stdout, stderr);
  document.getElementById('op-output').innerHTML = outHtml;
  st.outHtml = outHtml;

  await evaluate(stdout, stderr, code);

  if (st.status !== 'solved') {
    btn.disabled = false;
    btn.innerHTML = `<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg> RUN &amp; SUBMIT`;
  }
}

function buildOutputHtml(stdout, stderr) {
  if (stderr) {
    return `
      <div style="display:flex;flex-direction:column;align-items:center;justify-content:center;padding:28px 16px;gap:12px;text-align:center;">
        <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="var(--red)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
          <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
          <line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>
        </svg>
        <div style="font-family:var(--font-display);font-size:15px;font-weight:800;color:var(--red);letter-spacing:1px;">BUG NOT FIXED</div>
        <div style="font-size:12px;color:var(--text3);max-width:240px;line-height:1.6;">Your code has errors or produces incorrect output. Review the logic and try again.</div>
        ${stdout ? `<div style="width:100%;margin-top:8px;text-align:left;"><div style="color:var(--text3);font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:1px;margin-bottom:4px;">Partial Output</div><pre style="font-size:11px;color:var(--text2);">${escapeHtml(stdout)}</pre></div>` : ''}
      </div>`;
  }
  return `<div style="color:var(--neon);font-size:9px;font-weight:700;text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;">Output</div><pre>${escapeHtml(stdout)||'<span style="color:var(--text3);">(no output)</span>'}</pre>`;
}

// ── EVALUATE ─────────────────────────────────────────────────
async function evaluate(stdout, stderr, code) {
  const expected = (problem.expectedOutput || '').trim();
  const actual   = (stdout || '').trim();
  const passed   = !stderr && actual === expected;
  const elapsed  = getElapsed();
  const st       = problemStates[problem.id];
  // User-facing output: if there's a stderr/error, show friendly message
  const displayActual = stderr ? 'Bug not fixed — code has errors' : (actual || '(no output)');

  // Feature 2: Send code to admin
  await sendToAdmin(code, actual, stderr, passed, elapsed);

  // Save to main submissions table
  await DB.addSubmission({
    participantName: ME,
    problemId: problem.id,
    round: ROUND,
    submittedCode: code,
    actualOutput: actual || stderr || '',
    result: passed ? 'Pass' : 'Fail',
    timeTaken: elapsed,
    terminated: false,
  });

  await lockRoundAfterSubmission();

  const resHtml = `
    <div class="res-card ${passed?'pass':'fail'}">
      <span class="res-icon">${passed
        ? `<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="var(--neon)" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>`
        : `<svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="var(--red)" stroke-width="2"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>`
      }</span>
      <div class="res-label">${passed?'BUG FIXED!':'WRONG ANSWER'}</div>
      <div class="res-sub">${passed?'Output matches expected.':'Output does not match. Keep trying!'}</div>
    </div>
    <div class="cmp-wrap">
      <span class="cmp-lbl">Expected</span>
      <div class="cmp-box exp">${escapeHtml(expected||'(empty)')}</div>
      <span class="cmp-lbl">Your Output</span>
      <div class="cmp-box act">${escapeHtml(displayActual)}</div>
    </div>
    <div class="eval-note">
      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13"/><path d="M22 2L15 22 11 13 2 9l20-7z"/></svg>
      Code submitted to admin for evaluation
    </div>
  `;
  document.getElementById('result-area').innerHTML = resHtml;
  st.resHtml = resHtml;
  switchTab('result');

  if (passed) {
    st.status = 'solved';
    const btn = document.getElementById('run-btn');
    btn.disabled = true; btn.textContent = '✓ SOLVED';
    buildSidebar();
    await updateRoundProgress();
    showToast('Bug fixed! Correct!', 'success', 4000);

    const allSolved = allProblems.every(p => problemStates[p.id]?.status === 'solved');
    if (allSolved) {
      clearInterval(timerInterval);
      sessionLive = false; sessionDone = true; lockdownActive = false;
      setTimeout(() => showCompletion('allSolved', elapsed), 1200);
    } else {
      showToast('Switch to next question →', 'info', 2500);
    }
  } else {
    showToast('Wrong — try again!', 'error', 2500);
  }
}

// ── FEATURE 2: SEND CODE TO ADMIN ────────────────────────────
async function sendToAdmin(code, actualOutput, error, passed, elapsed) {
  await DB.addAdminSubmission({
    participantName: ME,
    problemId:       problem.id,
    problemTitle:    problem.title,
    language:        problem.language,
    round:           ROUND,
    submittedCode:   code,
    actualOutput:    actualOutput || error || '',
    expectedOutput:  problem.expectedOutput,
    result:          passed ? 'Pass' : 'Fail',
    timeTaken:       elapsed,
  });
}

// ── ROUND PROGRESS ────────────────────────────────────────────
async function updateRoundProgress() {
  const k  = ROUND === 2 ? 'round2Completed' : 'round1Completed';
  const sk = ROUND === 2 ? 'round2Status'    : 'round1Status';
  const n  = allProblems.filter(p => problemStates[p.id]?.status === 'solved').length;
  const upd = { [k]: n };
  if (n === allProblems.length && allProblems.length > 0) upd[sk] = 'completed';
  await DB.updateParticipant(ME, upd);
}

// ── END ALL SESSIONS (time up) ────────────────────────────────
async function endAllSessions(reason) {
  if (sessionDone) return;
  clearInterval(timerInterval);
  sessionLive = false; sessionDone = true; lockdownActive = false;

  for (const p of allProblems) {
    if (problemStates[p.id]?.status === 'unsolved') {
      const code = (p.id === problem.id && monacoEditor) ? monacoEditor.getValue() : (problemStates[p.id]?.code || '');
      await DB.addSubmission({
        participantName: ME, problemId: p.id, round: ROUND,
        submittedCode: code, actualOutput: '',
        result: reason, timeTaken: getElapsed(), terminated: false,
      });
      await sendToAdmin(code, '', '', false, getElapsed());
    }
  }
  await updateRoundProgress();
  if (document.fullscreenElement) document.exitFullscreen().catch(() => {});
  showCompletion('timeup', getElapsed());
}

// ── OVERLAYS ──────────────────────────────────────────────────
function showCompletion(type, elapsed) {
  lockdownActive = false;
  const icons  = {
    allSolved: `<svg width="76" height="76" viewBox="0 0 24 24" fill="none" stroke="var(--gold)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M8 21h8"/><path d="M12 17v4"/><path d="M7 4h10"/><path d="M17 4v4a5 5 0 0 1-10 0V4"/><path d="M5 4v2a4 4 0 0 0 4 4"/><path d="M19 4v2a4 4 0 0 1-4 4"/></svg>`,
    timeup: `<svg width="76" height="76" viewBox="0 0 24 24" fill="none" stroke="var(--yellow)" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>`
  };
  const titles = { allSolved:'ALL SOLVED!', timeup:"TIME'S UP" };
  const msgs   = { allSolved:'Excellent! You solved all problems in this round!', timeup:'The round timer ran out. Your results have been submitted.' };
  document.getElementById('co-icon').innerHTML  = icons[type]  || '';
  document.getElementById('co-title').textContent = titles[type] || 'DONE';
  document.getElementById('co-msg').textContent   = msgs[type]   || '';
  const n = allProblems.filter(p => problemStates[p.id]?.status === 'solved').length;
  document.getElementById('co-result').innerHTML = `
    <div style="background:var(--neon-dim);border:1px solid rgba(0,245,160,0.2);border-radius:var(--r2);padding:14px 28px;display:inline-block;">
      <div style="font-family:var(--font-display);font-size:18px;color:var(--neon);font-weight:700;">${n} / ${allProblems.length} SOLVED</div>
      <div style="font-size:11px;color:var(--text3);margin-top:4px;">Total time: ${elapsed}</div>
    </div>
  `;
  document.getElementById('complete-overlay').classList.add('show');
}

function showTermination(reason) {
  lockdownActive = false;
  document.getElementById('term-reason-box').textContent = reason;
  document.getElementById('term-overlay').classList.add('show');
}

// ── FEATURE 1: TAB SWITCH → 5s CONFIRMATION ──────────────────
function onTabSwitch() {
  if (!lockdownActive || sessionDone || tabPending) return;
  tabPending = true;

  // Pause round timer while dialog shows
  clearInterval(timerInterval);

  tabSecs = 5;
  document.getElementById('tc-num').textContent = tabSecs;
  updateCountdownRing(tabSecs, 5);
  document.getElementById('tab-confirm-overlay').classList.add('show');

  tabCountdown = setInterval(() => {
    tabSecs--;
    document.getElementById('tc-num').textContent = tabSecs;
    updateCountdownRing(tabSecs, 5);
    if (tabSecs <= 0) {
      clearInterval(tabCountdown);
      confirmTerminate(); // auto-terminate when countdown hits 0
    }
  }, 1000);
}

function updateCountdownRing(cur, total) {
  const deg = (cur / total) * 360;
  document.getElementById('tc-ring').style.background =
    `conic-gradient(var(--red) ${deg}deg, var(--bg3) ${deg}deg)`;
}

function confirmTerminate() {
  clearInterval(tabCountdown);
  tabPending = false;
  document.getElementById('tab-confirm-overlay').classList.remove('show');
  triggerTermination('Tab switch confirmed — session terminated by choice/timeout');
}

function cancelTerminate() {
  clearInterval(tabCountdown);
  tabPending = false;
  document.getElementById('tab-confirm-overlay').classList.remove('show');
  // Resume round timer
  if (sessionLive && !sessionDone) timerInterval = setInterval(tick, 1000);
  // Re-enter fullscreen
  document.documentElement.requestFullscreen().catch(() => {});
}

// ── LOCKDOWN ──────────────────────────────────────────────────
function activateLockdown() {
  lockdownActive = true;
  if (lockdownBound) return;
  lockdownBound = true;

  document.addEventListener('visibilitychange', () => {
    if (document.hidden && lockdownActive && !sessionDone && !tabPending)
      onTabSwitch();
  });

  window.addEventListener('blur', () => {
    if (lockdownActive && !sessionDone && !tabPending) {
      setTimeout(() => {
        if (!document.hasFocus() && lockdownActive && !sessionDone && !tabPending)
          onTabSwitch();
      }, 300);
    }
  });

  document.addEventListener('fullscreenchange', () => {
    if (!document.fullscreenElement && lockdownActive && !sessionDone) {
      if (!tabPending) onTabSwitch();
      setTimeout(() => document.documentElement.requestFullscreen().catch(() => {}), 400);
    }
  });

  window.addEventListener('pagehide', () => {
    if (lockdownActive && !sessionDone && !tabPending) onTabSwitch();
  });

  document.addEventListener('keydown', e => {
    const k = (e.key || '').toLowerCase();
    const blocked = k === 'f12' ||
      (e.ctrlKey && ['w','t','r','n','l','u','s','p','o','k','j','h','d','f'].includes(k)) ||
      (e.altKey && (k === 'f4' || k === 'tab' || k === 'left' || k === 'right')) ||
      k === 'escape' ||
      (e.metaKey && ['w','t','r','n','l','u'].includes(k));
    if (blocked && lockdownActive) { e.preventDefault(); e.stopPropagation(); }
  }, true);

  document.addEventListener('contextmenu', e => { if (lockdownActive) e.preventDefault(); });
  window.addEventListener('beforeunload', e => {
    if (lockdownActive && !sessionDone) { e.preventDefault(); e.returnValue = ''; }
  });
}

async function triggerTermination(reason) {
  if (terminationFired || sessionDone) return;
  terminationFired = true;
  lockdownActive = false; sessionLive = false; sessionDone = true;
  clearInterval(timerInterval); clearInterval(tabCountdown);

  const code = monacoEditor?.getValue() || '';

  // Save termination to DB
  await DB.addSubmission({
    participantName: ME, problemId: problem.id, round: ROUND,
    submittedCode: code, actualOutput: '',
    result: 'Terminated', timeTaken: getElapsed(), terminated: true,
  });
  await sendToAdmin(code, '', '', false, getElapsed());
  problemStates[problem.id].status = 'terminated';

  const sk = ROUND === 2 ? 'round2Status' : 'round1Status';
  await DB.updateParticipant(ME, { [sk]: 'terminated' });

  if (document.fullscreenElement) document.exitFullscreen().catch(() => {});
  showTermination(reason);
}

// ── MANUAL EXIT ───────────────────────────────────────────────
async function exitManual() {
  if (!confirm('Exit session? Your current attempt will be saved.')) return;
  lockdownActive = false; sessionDone = true;
  clearInterval(timerInterval);
  const code = monacoEditor?.getValue() || '';
  await DB.addSubmission({
    participantName: ME, problemId: problem.id, round: ROUND,
    submittedCode: code, actualOutput: '',
    result: 'Exited', timeTaken: getElapsed(), terminated: false,
  });
  await sendToAdmin(code, '', '', false, getElapsed());
  if (document.fullscreenElement) document.exitFullscreen().catch(() => {});
  window.location.href = 'participant.html';
}

function showToast(msg, type, dur = 3000) {
  const icons = {
    success: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--neon)" stroke-width="2"><path d="M20 6L9 17l-5-5"/></svg>`,
    error: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--red)" stroke-width="2"><path d="M18 6L6 18"/><path d="M6 6l12 12"/></svg>`,
    warn: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--yellow)" stroke-width="2"><path d="M12 9v4"/><path d="M12 17h.01"/><path d="M10.29 3.86 1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/></svg>`,
    info: `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="var(--cyan)" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>`
  };
  const t = document.createElement('div');
  t.className = `toast ${type}`;
  t.innerHTML = `<span>${icons[type]||''}</span><span>${msg}</span>`;
  document.body.appendChild(t);
  setTimeout(() => { t.style.opacity='0'; t.style.transition='opacity 0.3s'; setTimeout(()=>t.remove(),300); }, dur);
}

// Boot
init();
</script>
</body>
</html>